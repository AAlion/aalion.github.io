<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Happy Code, Happy Life">
<meta property="og:type" content="website">
<meta property="og:title" content="AAlion">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="AAlion">
<meta property="og:description" content="Happy Code, Happy Life">
<meta property="article:author" content="AAlion">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>AAlion</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AAlion</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我走得很慢，但我从不后退</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/01/Java002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AAlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AAlion">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/01/Java002/" itemprop="url">AQS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-01T00:00:03+00:00">
                2021-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>@<a href="目录">TOC</a></p>
<h4 id="AQS-AbstractQueuedSynchronizer-★"><a href="#AQS-AbstractQueuedSynchronizer-★" class="headerlink" title="AQS(AbstractQueuedSynchronizer) ★"></a>AQS(AbstractQueuedSynchronizer) ★</h4><ul>
<li><a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">AQS_zejian</a>|</li>
<li>unlock()操作必须在finally代码块中确保即使临界区执行抛出异常，线程最终也能正常释放锁</li>
</ul>
<h5 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h5><ul>
<li>Lock为接口，ReentrantLock是Lock的实现类</li>
<li>又名递归锁，ReentrantLock/Synchronized就是一个典型的可重入锁。</li>
<li>最大作用：避免死锁</li>
<li>可重入锁概念：</li>
</ul>
<p>– ReentrantLock翻译叫可重入锁。所谓可重入锁，顾名思义，指的是线程可以重复获取同一把锁。<br>– 同一个线程外层函数获得锁之后，内层递归函数仍然能够获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁<br>– 如下代码，当线程 T1 执行到 ①处时，已经获取到了锁 rtl ，当在 ① 处调用get() 方法时，会在 ② 再次对锁 rtl执行加锁操作。<br>此时，如果锁 rtl 是可重入的，那么线程T1可以再次加锁成功；如果锁 rtl 是不可重入的，那么线程 T1 此时会被阻塞。<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">final</span> Lock rtl = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	 <span class="keyword">int</span> value;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		 <span class="comment">// 获取锁</span></span><br><span class="line">		 rtl.lock(); ②</span><br><span class="line">		 <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			 <span class="comment">// 保证锁能释放</span></span><br><span class="line">			 rtl.unlock();</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		 <span class="comment">// 获取锁</span></span><br><span class="line">		 rtl.lock();</span><br><span class="line">		 <span class="keyword">try</span> &#123;</span><br><span class="line">			value = <span class="number">1</span> + get(); ①</span><br><span class="line">		 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			 <span class="comment">// 保证锁能释放</span></span><br><span class="line">			 rtl.unlock();</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>可重入函数<br>指的是多个线程可以同时调用该函数，每个线程都能得到正确结果；同时在一个线程内支持线程切换，无论被切换多少次，结果都是正确的。多线程可以同时执行，还支持线程切换，这意味着什么呢？线程安全啊。所以，可重入函数是线程安全的。</li>
</ul>
<h5 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h5><ul>
<li><a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">RL_zejian</a>|</li>
<li><strong>AQS原理及实现?</strong> </li>
</ul>
<ul>
<li>类在java.util.concurrent.locks包下面</li>
<li>概念<br>AQS是一个用来<strong><em>构建锁和同步器的框架</em></strong>，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</li>
<li>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。<br><img src="https://img-blog.csdnimg.cn/20200716013846411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="AQS原理图"></li>
<li>AQS 对资源的共享方式<br>AQS定义两种资源共享方式<br>① Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</li>
</ul>
<p>*公平锁：按照线程在队列中的排队顺序，先到者先拿到锁<br>*非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的<br>② Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。<br>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。<br>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p>
<ul>
<li>AQS底层使用了模板方法模式<br>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：<br>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）<br>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。<br>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。<br>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>
默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。<br>*以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</li>
</ul>
<p>*再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。<br>*一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<ul>
<li><p><a href="https://blog.csdn.net/wind_602/article/details/104161960" target="_blank" rel="noopener">⭐原理图示</a></p>
</li>
<li><p>—————————–具体——————-<br>AQS的原理概要，如下<a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">源码</a></p>
</li>
<li><p><strong>1 AQS工作原理概要</strong></p>
</li>
</ul>
<p>–概念：AbstractQueuedSynchronizer(AQS)又称为队列同步器；<br>–作用：用来构建锁或其他同步组件的基础框架；<br>–state：内部通过一个int类型的成员变量state来控制同步状态：<br>① 当state=0，则说明没有任何线程占有共享资源的锁；<br>② 当state=1，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待；<br>–同步队列：AQS内部通过内部类Node构成FIFO的同步队列来完成线程获取锁的排队工作；<br>–等待队列：AQS同时利用内部类ConditionObject构建等待队列，当Condition调用await()方法后，线程将会加入等待队列中，而当Condition调用signal()方法后，线程将从等待队列转移动同步队列中进行锁竞争。<br>注意：这里涉及到两种队列，一种的同步队列，当线程请求锁而等待后将加入同步队列等待，而另一种则是等待队列(可有多个)，通过Condition调用await()方法释放锁后，将加入等待队列。</p>
<ul>
<li><strong>2 AQS中的同步队列模型</strong></li>
<li><em>1）AQS*</em></li>
<li><em>–head和tail：*</em>分别是AQS中的变量。<br>head：指向同步队列的头部，注意head为空结点，不存储信息。<br>tail：指向同步队列的队尾，同步队列采用的是双向链表的结构这样可方便队列进行结点增删操作。</li>
<li><em>–state：*</em> state变量则是代表同步状态。<br>state=0：执行当线程调用lock方法进行加锁后，如果此时state的值为0，则说明当前线程可以获取到锁(在本篇文章中，锁和同步状态代表同一个意思)，同时将state设置为1，表示获取成功。<br>state=1：如果state已为1，也就是当前锁已被其他线程持有，那么当前执行线程将被封装为Node结点加入同步队列等待。</li>
<li><em>–Node结点：*</em>是对每一个访问同步代码的线程的封装。   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;** AQS抽象类*&#x2F;</span><br><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">    extends AbstractOwnableSynchronizer&#123;</span><br><span class="line">&#x2F;&#x2F;指向同步队列队头</span><br><span class="line">private transient volatile Node head;</span><br><span class="line">&#x2F;&#x2F;指向同步的队尾</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line">&#x2F;&#x2F;同步状态，0代表锁未被占用，1代表锁已被占用</span><br><span class="line">private volatile int state;</span><br><span class="line">&#x2F;&#x2F;省略其他代码......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210401134928488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><em>2）Node节点*</em><br>从图中的Node的数据结构也可看出，其<strong>包含了需要同步的线程本身以及线程的状态</strong>，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个Node结点内部关联其前继结点prev和后继结点next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程，Node是AQS的内部类，其数据结构如下：</li>
<li><em>– SHARED(shared)和EXCLUSIVE(exclusive)常量：*</em>分别代表共享模式和独占模式。<br>① 共享模式：是一个锁允许多条线程同时操作；<br>如信号量Semaphore采用的就是基于AQS的共享模式实现的。<br>② 独占模式：是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待；<br>如ReentranLock。</li>
<li><em>–waitStatus变量：*</em>表示当前被封装成Node结点的等待状态。<br>共4种：<br>① CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。<br>② SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。<br>③ CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。<br>④ PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。<br>⑤ 0状态：值为0，代表初始化状态。</li>
<li><em>–pre和next：*</em>分别指向当前Node结点的前驱结点和后继结点；</li>
<li><em>–thread变量：*</em>存储的请求锁的线程。</li>
<li><em>–nextWaiter：*</em>与Condition相关，代表等待队列中的后继结点，后续会有更详细的分析。   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final class Node &#123;</span><br><span class="line">    static final Node SHARED &#x3D; new Node();   &#x2F;&#x2F;共享模式</span><br><span class="line">    static final Node EXCLUSIVE &#x3D; null;   &#x2F;&#x2F;独占模式</span><br><span class="line">    static final int CANCELLED &#x3D;  1;   &#x2F;&#x2F;标识线程已处于结束状态</span><br><span class="line">    static final int SIGNAL    &#x3D; -1;    &#x2F;&#x2F;等待被唤醒状态</span><br><span class="line">    static final int CONDITION &#x3D; -2;    &#x2F;&#x2F;条件状态，</span><br><span class="line">    static final int PROPAGATE &#x3D; -3; &#x2F;&#x2F;在共享模式中使用表示获得的同步状态会被传播</span><br><span class="line">    volatile int waitStatus; &#x2F;&#x2F;等待状态,存在CANCELLED、SIGNAL、</span><br><span class="line">                                       &#x2F;&#x2F;CONDITION、PROPAGATE 4种</span><br><span class="line">    volatile Node prev;   &#x2F;&#x2F;同步队列中前驱结点</span><br><span class="line">    volatile Node next;   &#x2F;&#x2F;同步队列中后继结点</span><br><span class="line">    volatile Thread thread;    &#x2F;&#x2F;请求锁的线程</span><br><span class="line">    Node nextWaiter;   &#x2F;&#x2F;等待队列中的后继结点，这个与Condition有关</span><br><span class="line">    final boolean isShared() &#123;   &#x2F;&#x2F;判断是否为共享模式</span><br><span class="line">        return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;  &#x2F;&#x2F;获取前驱结点</span><br><span class="line">        Node p &#x3D; prev;</span><br><span class="line">        if (p &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><em>3）总结*</em><br>总之呢，AQS作为基础组件，对于锁的实现存在两种不同的模式，即共享模式(如Semaphore)和独占模式(如ReetrantLock)，无论是共享模式还是独占模式的实现类，其内部都是基于AQS实现的，也都维持着一个虚拟的同步队列，当请求锁的线程超过现有模式的限制时，会将线程包装成Node结点并将线程当前必要的信息存储到node结点中，然后加入同步队列等会获取锁，而这系列操作都有AQS协助我们完成，这也是作为基础组件的原因，无论是Semaphore还是ReetrantLock，其内部绝大多数方法都是间接调用AQS完成的。<br>下面是AQS整体类图结构：<br><img src="https://img-blog.csdnimg.cn/2021040114195319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><em>4）ReentrantLock与AQS的关系*</em></li>
<li><em>1&gt; ReentrantLock类和继承：*</em></li>
</ul>
<p>–AbstractOwnableSynchronizer：抽象类，定义了存储独占当前锁的线程和获取的方法<br>–AbstractQueuedSynchronizer：抽象类，AQS框架核心类，其内部以虚拟队列的方式管理线程的锁获取与锁释放，其中获取锁(tryAcquire方法)和释放锁(tryRelease方法)并没有提供默认实现，需要子类重写这两个方法实现具体逻辑，目的是使开发人员可以自由定义获取锁以及释放锁的方式。<br>–Node：AbstractQueuedSynchronizer 的内部类，用于构建虚拟队列(链表双向链表)，管理需要获取锁的线程。<br>–Sync：抽象类，是ReentrantLock的内部类，<strong>继承自AbstractQueuedSynchronizer</strong>，实现了释放锁的操作(tryRelease()方法)，并提供了lock抽象方法，由其子类实现。<br>–NonfairSync：是ReentrantLock的内部类，继承自Sync，非公平锁的实现类。<br>–FairSync：是ReentrantLock的内部类，继承自Sync，公平锁的实现类。<br>–ReentrantLock：实现了Lock接口的，其内部类有Sync、NonfairSync、FairSync，在创建时可以根据fair参数决定创建NonfairSync(默认非公平锁)还是FairSync。<br><img src="https://img-blog.csdnimg.cn/20210401142117583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2&gt; ReentrantLock内部类：</strong><br>–ReentrantLock内部存在3个实现类，分别是Sync、NonfairSync、FairSync。<br>–ReentrantLock的所有方法调用都通过间接调用AQS和Sync类及其子类来完成的。<br>–Sync类：继承自AQS实现了解锁tryRelease()方法；<br>–NonfairSync(非公平锁)、 FairSync(公平锁)则继承自Sync，实现了获取锁的tryAcquire()方法；<br><strong>3&gt; AQS</strong><br>–AQS提供功能：<br>AQS是一个抽象类，但其源码中并没一个抽象的方法，这是因为AQS只是作为一个基础组件，并不希望直接作为直接操作类对外输出，而更倾向于作为基础组件，为真正的实现类提供基础设施，如构建同步队列，控制同步状态等，事实上，从设计模式角度来看，AQS采用的模板模式的方式构建的，其内部除了提供并发操作核心方法以及同步队列操作外，还提供了一些模板方法让子类自己实现，如加锁操作以及解锁操作，为什么这么做？<br>–为什么？设计理念：<br>这是因为AQS作为基础组件，封装的是核心并发操作，但是实现上分为两种模式，即共享模式与独占模式，而这两种模式的加锁与解锁实现方式是不一样的，但AQS只关注内部公共方法实现并不关心外部不同模式的实现，所以提供了模板方法给子类使用，也就是说实现独占锁，<br>如ReentrantLock需要自己实现tryAcquire()方法和tryRelease()方法，而实现共享模式的Semaphore，则需要实现tryAcquireShared()方法和tryReleaseShared()方法，<br>–好处：无论是共享模式还是独占模式，其基础的实现都是同一套组件(AQS)，只不过是加锁解锁的逻辑不同罢了，更重要的是如果我们需要自定义锁的话，也变得非常简单，只需要选择不同的模式实现不同的加锁和解锁的模板方法即可，AQS提供给独占模式和共享模式的模板方法如下<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;AQS中提供的主要模板方法，由子类实现。</span><br><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">    extends AbstractOwnableSynchronizer&#123;</span><br><span class="line">    protected boolean tryAcquire(int arg) &#123;     &#x2F;&#x2F;独占模式下获取锁的方法</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    protected boolean tryRelease(int arg) &#123;    &#x2F;&#x2F;独占模式下解锁的方法</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    protected int tryAcquireShared(int arg) &#123;   &#x2F;&#x2F;共享模式下获取锁的方法</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    protected boolean tryReleaseShared(int arg) &#123;   &#x2F;&#x2F;共享模式下解锁的方法</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    protected boolean isHeldExclusively() &#123;   &#x2F;&#x2F;判断是否为持有独占锁</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="ReentrantLock-公平锁-非公平锁"><a href="#ReentrantLock-公平锁-非公平锁" class="headerlink" title="ReentrantLock-公平锁|非公平锁"></a>ReentrantLock-公平锁|非公平锁</h5><ul>
<li>ReetrantLock，实现Lock接口，与synchronized作用相当，比其更灵活</li>
<li>ReetrantLock是基于AQS并发框架实现</li>
</ul>
<ol>
<li><strong>公平锁、非公平锁</strong>（sxt2）</li>
</ol>
<ul>
<li><strong>是什么</strong></li>
<li>公平锁：是指多个线程按照<strong><em>申请锁的顺序</em></strong>来获取锁，满足FIFO。</li>
<li>非公平：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比现申请的线程优先获得锁，在高并发的情况下，有可能会造成优先级反战或者饥饿现象</li>
<li><strong>区别</strong></li>
<li>公平锁：就是很公平，在并发环境中，每个线程获取锁时会查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则加入等待队列，以后会按照FIFO的规则从队列中取到自己</li>
<li>非公平锁：比较粗鲁，上来就尝试占有锁，如果尝试失败，在采用类似公平锁的方式（非公平锁的优点在于吞吐量比公平锁大）</li>
<li><strong>其他</strong><br>Syschronized而言，也是非公平锁（类似lock）</li>
<li><strong>ReentrantLock实现公平和非公平锁</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//方法1:无参构造函数：默认非公平锁</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync(); <span class="comment">// 非公平锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法2：true时为公平锁，false时为非公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123; </span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ReentrantLock的创建可以制定构造函数的boolean类型来得到公平锁或非</li>
</ul>
</li>
<li>在入口等待队列，锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。</li>
</ul>
<p>– 如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；<br>– 如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。</p>
<ul>
<li>—————————-具体——————————-<br><img src="https://img-blog.csdnimg.cn/20210401220852189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>AQS的实现过程：基于ReetrantLock进一步分析AQS独占模式实现过程，这也是ReetrantLock的内部实现原理。</li>
<li><strong>1 ReetrantLock中非公平锁-lock</strong></li>
</ul>
<p>–AQS实现：<br>AQS同步器的实现依赖于内部的同步队列(FIFO的双向链表对列)完成对同步状态(state)的管理，当前线程获取锁(同步状态)失败时，AQS会将该线程以及相关等待信息包装成一个节点(Node)并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会将头结点head中的线程唤醒，让其尝试获取同步状态。<br>–这里重点分析一下<strong>获取同步状态和释放同步状态以及如何加入队列的具体操作</strong>，这里从ReetrantLock入手分析AQS的具体实现，先以非公平锁为例进行分析。<br>–非公平锁<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ReentrantLock() &#123;  &#x2F;&#x2F;默认构造，创建非公平锁NonfairSync</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;  &#x2F;&#x2F;根据传入参数创建锁类型</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">public void lock() &#123;  &#x2F;&#x2F;加锁操作 √</span><br><span class="line">     sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>–sync是个抽象类：<br>存在两个不同的实现子类，从非公平锁NonfairSync子类入手：流程：<br><strong>1）lock加锁</strong><br>获取锁时，首先对同步状态执行CAS操作，尝试把state的状态从0设置为1 -&gt;<br>① 返回true：则代表获取同步状态成功，也就是当前线程获取锁成，可操作临界资源；<br>② 返回false： 则表示已有线程持有该同步状态(其值为1)，获取锁失败，注意这里存在并发的情景，也就是可能同时存在多个线程设置state变量，因此是CAS操作保证了state变量操作的原子性。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**非公平锁实现*&#x2F;</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    final void lock() &#123;   &#x2F;&#x2F;加锁</span><br><span class="line">        if (compareAndSetState(0, 1))    &#x2F;&#x2F;执行CAS操作，获取同步状态</span><br><span class="line">       &#x2F;&#x2F;成功则将独占锁线程设置为当前线程  </span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);   &#x2F;&#x2F;否则再次请求同步状态</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>2）lock-&gt;acquire(1)</strong><br>返回false后，执行 acquire(1)-AQS方法，该方法是AQS中的方法，它对中断不敏感，即使线程获取同步状态失败，进入同步队列，后续对该线程执行中断操作也不会从同步队列中移出，方法如下<br>—传入参数arg：表示要获取同步状态后设置的值(即要设置state的值)；<br>因为要获取锁，而status为0时是释放锁，1则是获取锁，所以一般传递参数为1，进入方法后首先会执行tryAcquire(arg)-ReetrantLock方法；<br>在前面分析过该方法在AQS中并没有具体实现，而是交由子类实现，因此该方法是由ReetrantLock类内部实现的<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;   &#x2F;&#x2F;再次尝试获取同步状态</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;  </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>3）tryAcquire(arg)</strong><br>–tryAcquire(arg)在ReetrantLock的实现<br>–做了两件事：<br>① 尝试再次获取同步状态，如果获取成功则将当前线程设置为OwnerThread，否则失败；<br>② 判断当前线程current是否为OwnerThread，如果是则属于重入锁，state自增1，并获取锁成功，返回true，反之失败，返回false，也就是tryAcquire(arg)执行失败，返回false。<br>–注意：与公平锁不同的点：<br>nonfairTryAcquire(int acquires)内部使用的是CAS原子性操作设置state值，可以保证state的更改是线程安全的，因此只要任意一个线程调用nonfairTryAcquire(int acquires)方法并设置成功即可获取锁，不管该线程是新到来的还是已在同步队列的线程；<br>非公平锁特性，并不保证同步队列中的线程一定比新到来线程请求(可能是head结点刚释放同步状态然后新到来的线程恰好获取到同步状态)先获取到锁。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1 NonfairSync类</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">         return nonfairTryAcquire(acquires);  &#x2F;&#x2F;由nonfairTryAcquire实现</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F;2 Sync类</span><br><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">  final boolean nonfairTryAcquire(int acquires) &#123;   &#x2F;&#x2F;nonfairTryAcquire方法</span><br><span class="line">      final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">      int c &#x3D; getState();</span><br><span class="line">      if (c &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F;判断同步状态是否为0，并尝试再次获取同步状态</span><br><span class="line">          if (compareAndSetState(0, acquires)) &#123;    &#x2F;&#x2F;执行CAS操作</span><br><span class="line">              setExclusiveOwnerThread(current);</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;如果当前线程已获取锁，属于重入锁，再次获取锁后将status值加1</span><br><span class="line">      else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">          int nextc &#x3D; c + acquires;</span><br><span class="line">          if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">              throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">          &#x2F;&#x2F;设置当前同步状态，当前只有一个线程持有锁，因为不会发生线程安全问题，可以直接执行 setState(nextc);</span><br><span class="line">          setState(nextc);</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>4）再看acquire(int arg)</strong><br>–理想情况：tryAcquire(arg)返回true，acquireQueued不执行，因为毕竟当前线程已获取到锁；<br>–tryAcquire(arg)返回false，则会执行addWaiter(Node.EXCLUSIVE)进行入队操作,由于ReentrantLock属于独占锁，因此结点类型为Node.EXCLUSIVE<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;   &#x2F;&#x2F;再次尝试获取同步状态</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;  </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>5）addWaiter</strong><br>–创建Node：<br>创建了一个Node.EXCLUSIVE类型Node结点用于封装线程及其相关信息<br>–tail：其中，tail是AQS的成员变量，指向队尾(这点前面的我们分析过AQS维持的是一个双向的链表结构同步队列)；<br>-&gt; 如果是第一个结点，则为tail肯定为空，那么将执行enq(node)操作，如果非第一个结点即tail指向不为null，直接尝试执行CAS操作加入队尾，如果CAS操作失败还是会执行enq(node)：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    &#x2F;&#x2F;将请求同步状态失败的线程封装成结点</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    &#x2F;&#x2F;如果是第一个结点加入肯定为空，跳过。</span><br><span class="line">    &#x2F;&#x2F;如果非第一个结点则直接执行CAS入队操作，尝试在尾部快速添加</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        &#x2F;&#x2F;使用CAS执行尾部结点替换，尝试在尾部快速添加</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果第一次加入或者CAS操作没有成功执行enq入队操作</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>6）enq(node)</strong><br>–死循环：使用一个死循环进行CAS操作，可以解决多线程并发问题。<br>–做了两件事<br>① 如果还没有初始同步队列则创建新结点并使用compareAndSetHead设置头结点，tail也指向head；<br>② 队列已存在，则将新结点node添加到队尾。<br>注意：这两个步骤都存在同一时间多个线程操作的可能，如果有一个线程修改head和tail成功，那么其他线程将继续循环，直到修改成功，这里使用CAS原子操作进行头结点设置和尾结点tail替换可以保证线程安全，从这里也可以看出head结点本身不存在任何数据，它只是作为一个牵头结点，而tail永远指向尾部结点(前提是队列不为null)。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;   &#x2F;&#x2F;死循环</span><br><span class="line">         Node t &#x3D; tail;</span><br><span class="line">         &#x2F;&#x2F;如果队列为null，即没有头结点</span><br><span class="line">         if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">             &#x2F;&#x2F;创建并使用CAS设置头结点</span><br><span class="line">             if (compareAndSetHead(new Node()))</span><br><span class="line">                 tail &#x3D; head;</span><br><span class="line">         &#125; else &#123;&#x2F;&#x2F;队尾添加新结点</span><br><span class="line">             node.prev &#x3D; t;</span><br><span class="line">             if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                 t.next &#x3D; node;</span><br><span class="line">                 return t;</span><br><span class="line">             &#125; &#125;&#125;&#125;</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/2021040117002832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>7）再看acquire()-&gt;acquireQueued()</strong><br>–添加到同步队列后，结点就会进入一个自旋过程，即每个结点都在观察时机待条件满足获取同步状态，然后从同步队列退出并结束自旋；<br>–回到之前的acquire()方法，自旋过程是在acquireQueued(addWaiter(Node.EXCLUSIVE), arg))方法中执行的；<br>–自旋过程：<br>—当前线程在自旋(死循环)中获取同步状态，<br>—当且仅当前驱结点为头结点才尝试获取同步状态，这符合FIFO的规则，即先进先出，其次head是当前获取同步状态的线程结点，只有当head释放同步状态唤醒后继结点，后继结点才有可能获取到同步状态，因此后继结点在其前继结点为head时，才进行尝试获取同步状态，其他时刻将被挂起。<br>—进入if语句后调用setHead(node)方法，将当前线程结点设置为head<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;   &#x2F;&#x2F;自旋，死循环</span><br><span class="line">            final Node p &#x3D; node.predecessor();   &#x2F;&#x2F;获取前驱结点</span><br><span class="line">             &#x2F;&#x2F; 1 当且仅当p为头结点才尝试获取同步状态</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);  &#x2F;&#x2F;将node设置为头结点</span><br><span class="line">                p.next &#x3D; null;  &#x2F;&#x2F;清空原来头结点的引用便于GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;2 如果前驱结点不是head，判断是否挂起线程</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);  &#x2F;&#x2F;最终都没能获取同步状态，结束该线程的请求</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>8）setHead(node)</strong><br>–设置为node结点被设置为head后，其thread信息和前驱结点将被清空，因为该线程已获取到同步状态(锁)，正在执行了，也就没有必要存储相关信息了，head只有保存指向后继结点的指针即可；<br>–便于head结点释放同步状态后唤醒后继结点，执行结果如下图<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置为头结点</span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">        head &#x3D; node;</span><br><span class="line">        &#x2F;&#x2F;清空结点数据</span><br><span class="line">        node.thread &#x3D; null;</span><br><span class="line">        node.prev &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>–从图可知更新head结点的指向，将后继结点的线程唤醒并获取同步状态，调用setHead(node)将其替换为head结点，清除相关无用数据<br><img src="https://img-blog.csdnimg.cn/20210401170956117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>9）shouldParkAfterFailedAcquire()</strong><br>–如果前驱结点不是head执行shouldParkAfterFailedAcquire()方法<br>–作用：判断当前结点的前驱结点是否为SIGNAL状态(即等待唤醒状态)，如果是则返回true。<br>如果结点的ws为CANCELLED状态(值为1&gt;0),即结束状态，则说明该前驱结点已没有用应该从同步队列移除，执行while循环，直到寻找到非CANCELLED状态的结点。<br>倘若前驱结点的ws值不为CANCELLED，也不为SIGNAL(当从Condition的条件等待队列转移到同步队列时，结点状态为CONDITION因此需要转换为SIGNAL)，那么将其转换为SIGNAL状态，等待被唤醒。<br>–shouldParkAfterFailedAcquire()方法返回true：<br>即前驱结点为SIGNAL状态同时又不是head结点，那么使用parkAndCheckInterrupt()方法挂起当前线程，称为WAITING状态，需要等待一个unpark()操作来唤醒它，到此ReetrantLock内部间接通过AQS的FIFO的同步队列就完成了lock()操作。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果前驱结点不是head，判断是否挂起线程</span><br><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())</span><br><span class="line"></span><br><span class="line">      interrupted &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取当前结点的等待状态</span><br><span class="line">        int ws &#x3D; pred.waitStatus;</span><br><span class="line">        &#x2F;&#x2F;如果为等待唤醒（SIGNAL）状态则返回true</span><br><span class="line">        if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">            return true;</span><br><span class="line">        &#x2F;&#x2F;如果ws&gt;0 则说明是结束状态，</span><br><span class="line">        &#x2F;&#x2F;遍历前驱结点直到找到没有结束状态的结点</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果ws小于0又不是SIGNAL状态，</span><br><span class="line">            &#x2F;&#x2F;则将其设置为SIGNAL状态，代表该结点的线程正在等待唤醒。</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        &#x2F;&#x2F;将当前线程挂起</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        &#x2F;&#x2F;获取线程中断状态,interrupted()是判断当前中断状态，</span><br><span class="line">        &#x2F;&#x2F;并非中断线程，因此可能true也可能false,并返回</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>–总结成逻辑流程图：<br><img src="https://img-blog.csdnimg.cn/20210401171749785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>2 ReetrantLock中非公平锁-可中断lock</strong></li>
</ul>
<p>–获取锁的操作，这里看看另外一种可中断的获取方式，即调用ReentrantLock类的<strong>lockInterruptibly()或者tryLock()方法</strong>，最终它们都间接调用到doAcquireInterruptibly()<br><strong>1）doAcquireInterruptibly()</strong><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">private void doAcquireInterruptibly(int arg)</span><br><span class="line">       throws InterruptedException &#123;</span><br><span class="line">       final Node node &#x3D; addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       boolean failed &#x3D; true;</span><br><span class="line">       try &#123;</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               final Node p &#x3D; node.predecessor();</span><br><span class="line">               if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                   failed &#x3D; false;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   &#x2F;&#x2F;直接抛异常，中断线程的同步状态请求</span><br><span class="line">                   throw new InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br><strong>–最大的不同是：</strong><br>–检测到线程的中断操作后，直接抛出异常，从而中断线程的同步状态请求，移除同步队列。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">     &#x2F;&#x2F;直接抛异常，中断线程的同步状态请求</span><br><span class="line">       throw new InterruptedException();</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>3 ReetrantLock中非公平锁-unlock()</strong></li>
<li><em>1）release(1)*</em></li>
</ul>
<p>–释放锁实现：<br>释放同步状态的操作相对简单些，tryRelease(int releases)方法是ReentrantLock类中内部类自己实现的，因为AQS对于释放锁并没有提供具体实现，必须由子类自己实现。<br>–唤醒：<br>释放同步状态后会使用unparkSuccessor(h)唤醒后继结点的线程；<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;  &#x2F;&#x2F;ReentrantLock类的unlock</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line">public final boolean release(int arg) &#123; &#x2F;&#x2F;AQS类的release()方法</span><br><span class="line">    if (tryRelease(arg)) &#123;    &#x2F;&#x2F;尝试释放锁</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);  &#x2F;&#x2F;唤醒后继结点的线程</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ReentrantLock类中的内部类Sync实现的tryRelease(int releases) </span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">      int c &#x3D; getState() - releases;</span><br><span class="line">      if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">          throw new IllegalMonitorStateException();</span><br><span class="line">      boolean free &#x3D; false;</span><br><span class="line">      if (c &#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F;判断状态是否为0，如果是则说明已释放同步状态</span><br><span class="line">          free &#x3D; true;</span><br><span class="line">          setExclusiveOwnerThread(null);   &#x2F;&#x2F;设置Owner为null</span><br><span class="line">      &#125;</span><br><span class="line">      setState(c);  &#x2F;&#x2F;设置更新同步状态</span><br><span class="line">      return free;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><strong>2）unparkSuccessor(h)</strong><br>–作用：用unpark()唤醒同步队列中最前边未放弃线程(也就是状态为CANCELLED的线程结点s)。<br>–前面acquireQueued()：进入自旋的函数acquireQueued()，s结点的线程被唤醒后，会进入acquireQueued()函数的if (p == head &amp;&amp; tryAcquire(arg))的判断，如果p!=head也不会有影响，因为它会执行shouldParkAfterFailedAcquire()，由于s通过unparkSuccessor()操作后已是同步队列中最前边未放弃的线程结点，那么通过shouldParkAfterFailedAcquire()内部对结点状态的调整，s也必然会成为head的next结点，因此再次自旋时p==head就成立了，然后s把自己设置成head结点，表示自己已经获取到资源了，最终acquire()也返回了，这就是<strong>独占锁释放的过程</strong>。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F;这里，node一般为当前线程所在的结点。</span><br><span class="line">    int ws &#x3D; node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)  &#x2F;&#x2F;置零当前线程所在的结点状态，允许失败。</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    Node s &#x3D; node.next;  &#x2F;&#x2F;找到下一个需要唤醒的结点s</span><br><span class="line">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;&#x2F;&#x2F;如果为空或已取消</span><br><span class="line">        s &#x3D; null;</span><br><span class="line">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            if (t.waitStatus &lt;&#x3D; 0)  &#x2F;&#x2F;从这里可以看出，&lt;&#x3D;0的结点，都是还有效的结点。</span><br><span class="line">                s &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s !&#x3D; null)</span><br><span class="line">        LockSupport.unpark(s.thread);   &#x2F;&#x2F;唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>–总结：<br>在AQS同步器中维护着一个同步队列，当线程获取同步状态失败后，将会被封装成Node结点，加入到同步队列中并进行自旋操作，当当前线程结点的前驱结点为head时，将尝试获取同步状态，获取成功将自己设置为head结点。在释放同步状态时，则通过调用子类(ReetrantLock中的Sync内部类)的tryRelease(int releases)方法释放同步状态，释放成功则唤醒后继结点的线程。</p>
<ul>
<li><strong>4 ReetrantLock中公平锁</strong></li>
</ul>
<p>–与非公平锁不同的：<br>在获取锁的时，公平锁的获取顺序是完全遵循时间上的FIFO规则，也就是说先请求的线程一定会先获取锁，后来的线程肯定需要排队，这点与前面我们分析非公平锁的nonfairTryAcquire(int acquires)方法实现有锁不同，下面是公平锁中tryAcquire()方法的实现<br>–该方法与nonfairTryAcquire(int acquires)方法<strong>唯一的不同是在使用CAS设置尝试设置state值前，调用了hasQueuedPredecessors()判断同步队列是否存在结点，如果存在必须先执行完同步队列中结点的线程，当前线程进入等待状态。</strong><br>–这就是非公平锁与公平锁最大的区别：<br>公平锁在线程请求到来时先会判断同步队列是否存在结点，如果存在先执行同步队列中的结点线程，当前线程将封装成node加入同步队列等待。<br>非公平锁，当线程请求到来时，不管同步队列是否存在线程结点，直接尝试获取同步状态，获取成功直接访问共享资源。<br>注意：在绝大多数情况下，非公平锁才是我们理想的选择，毕竟从效率上来说非公平锁总是胜于公平锁。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;公平锁FairSync类中的实现</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;注意！！这里先判断同步队列是否存在结点</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>5 小结</strong><br>以上便是ReentrantLock的内部实现原理，这里我们简单进行小结，重入锁ReentrantLock，是一个基于AQS并发框架的并发控制类，其内部实现了3个类，分别是Sync、NoFairSync以及FairSync类，其中Sync继承自AQS，实现了释放锁的模板方法tryRelease(int)，而NoFairSync和FairSync都继承自Sync，实现各种获取锁的方法tryAcquire(int)。ReentrantLock的所有方法实现几乎都间接调用了这3个类，因此当我们在使用ReentrantLock时，大部分使用都是在间接调用AQS同步器中的方法，这就是ReentrantLock的内部实现原理,最后给出张类图结构<br><img src="https://img-blog.csdnimg.cn/20210401182012555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/01/Java001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AAlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AAlion">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/01/Java001/" itemprop="url">Kafka初识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-01T00:00:01+00:00">
                2021-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>@<a href="目录">TOC</a></p>
<h2 id="一、Kafka概念"><a href="#一、Kafka概念" class="headerlink" title="一、Kafka概念"></a>一、Kafka概念</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><ul>
<li><strong>1 定义</strong><br>Kafka是一个分布式的基于发布/订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。</li>
<li>总结：<br>是一个分布式消息队列，流式计算中，一般用来缓存数据，具有统一、高吞吐、低等待的特性。</li>
<li>具体：<br>在流式计算中，Kafka一般用来缓存数据，Storm通过消费Kafka的数据进行计算。<br>1）Apache  Kafka是一个开源消息系统，由Scala写成。是由Apache软件基金会开发的一个开源消息系统项目。<br>2）Kafka最初是由LinkedIn公司开发，并于2011年初开源。2012年10月从Apache Incubator毕业。该项目的目标是为处理实时数据提供一个统一、高通量、低等待的平台。<br>3）Kafka是一个分布式消息队列。Kafka对消息保存时根据Topic进行归类，发送消息者称为Producer，消息接受者称为Consumer，此外kafka集群有多个kafka实例组成，每个实例(server)称为broker。<br>4）无论是kafka集群，还是consumer都依赖于zookeeper集群保存一些meta信息，来保证系统可用性。</li>
</ul>
<h3 id="2-Kafka架构"><a href="#2-Kafka架构" class="headerlink" title="2. Kafka架构"></a>2. Kafka架构</h3><h4 id="1-基础架构"><a href="#1-基础架构" class="headerlink" title="1-基础架构"></a>1-基础架构</h4><p>1）Producer ：消息生产者，就是向kafka broker发消息的客户端；<br>2）Consumer ：消息消费者，向kafka broker取消息的客户端；<br>3）Consumer Group （CG）：消费者组，由多个consumer组成。<strong>消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。</strong>所有的消费者都属于某个消费者组，即<strong>消费者组是逻辑上的一个订阅者</strong>。<br>4）Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。<br>5）Topic ：可以理解为一个队列，<strong>生产者和消费者面向的都是一个topic</strong>；<br>6）Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，<strong>一个topic可以分为多个partition</strong>，每个partition是一个有序的队列；<br>7）Replica：副本，为保证集群中的某个节点发生故障时，<strong>该节点上的partition数据不丢失，且kafka仍然能够继续工作</strong>，kafka提供了副本机制，一个topic的每个分区都有若干个副本，一个leader和若干个follower。<br>8）leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader。<br>9）follower：每个分区多个副本中的“从”，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时，某个follower会成为新的follower。<br><img src="https://img-blog.csdnimg.cn/20210327111441704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-工作流程及文件存储机制"><a href="#2-工作流程及文件存储机制" class="headerlink" title="2-工作流程及文件存储机制"></a>2-工作流程及文件存储机制</h4><h6 id="1-工作流程"><a href="#1-工作流程" class="headerlink" title="1 工作流程"></a>1 工作流程</h6><p>– Kafka中消息是以topic进行分类的，生产者生产消息，消费者消费消息，都是面向topic的。</p>
<p>tips：Kafka只能保证区内有序，而不能保证全局有序<br><img src="https://img-blog.csdnimg.cn/20210327131042798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>官网图：<br><img src="https://img-blog.csdnimg.cn/20210327130558619.png" alt=""></p>
<h6 id="2-文件存储机制-日志结构"><a href="#2-文件存储机制-日志结构" class="headerlink" title="2 文件存储机制 -日志结构"></a>2 文件存储机制 -日志结构</h6><p>– topic是逻辑上的概念，而partition是物理上的概念，每个partition对应于一个log文件，该log文件中存储的就是producer生产的数据。Producer生产的数据会被不断追加到该log文件末端，且每条数据都有自己的offset。消费者组中的每个消费者，都会实时记录自己消费到了哪个offset，以便出错恢复时，从上次的位置继续消费。<br><img src="https://img-blog.csdnimg.cn/20210327132556852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>– 由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，Kafka采取了<strong>分片和索引机制</strong>，将每个partition分为多个segment。每个segment对应两个文件——“.index”文件和“.log”文件。这些文件位于一个文件夹下，该文件夹的命名规则为：topic名称+分区序号。例如，first这个topic有三个分区，则其对应的文件夹为first-0,first-1,first-2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000.index</span><br><span class="line">00000000000000000000.log</span><br><span class="line">00000000000000170410.index</span><br><span class="line">00000000000000170410.log</span><br><span class="line">00000000000000239430.index</span><br><span class="line">00000000000000239430.log</span><br></pre></td></tr></table></figure>
<p>index和log文件以当前segment的第一条消息的offset命名。下图为index文件和log文件的结构示意图:<br><strong>“.index”文件存储大量的索引信息，“.log”文件存储大量的数据</strong>，索引文件中的元数据指向对应数据文件中message的物理偏移地址。<br>tips：索引信息还包含对应数据的大小、seed方法<br><img src="https://img-blog.csdnimg.cn/20210327132948649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>补充：</strong><br>日志中包含多个日志段，而每个日志段又包含：消息日志文件、位移索引文件、时间戳索引文件、已终止的事务索引文件。<br><img src="https://img-blog.csdnimg.cn/20210408112934730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3-生产者"><a href="#3-生产者" class="headerlink" title="3-生产者"></a>3-生产者</h4><h5 id="1-gt-分区策略"><a href="#1-gt-分区策略" class="headerlink" title="1&gt; 分区策略"></a>1&gt; 分区策略</h5><ul>
<li><strong>1）分区的原因</strong><br>（1）方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；—注：即负载均衡<br>（2）可以提高并发，因为可以以Partition为单位读写了。</li>
<li><strong>2）分区的原则</strong><br>我们需要将producer发送的数据封装成一个<strong>ProducerRecord对象</strong>。<br>（1）指明partition 的情况下，直接将指明的值直接作为partiton 值；<br>（2）没有指明partition 值但有key 的情况下，将key 的hash 值与topic 的partition 数进行取余得到partition 值；<br>（3）既没有partition 值又没有key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与topic 可用的partition 总数取余得到partition 值，也就是常说的round-robin 算法<br><img src="https://img-blog.csdnimg.cn/20210327134938950.png" alt="在这里插入图片描述"></li>
</ul>
<h5 id="2-gt-数据可靠性保证—重复、一致"><a href="#2-gt-数据可靠性保证—重复、一致" class="headerlink" title="2&gt; 数据可靠性保证—重复、一致"></a>2&gt; 数据可靠性保证—重复、一致</h5><ul>
<li><strong>为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。</strong><br><img src="https://img-blog.csdnimg.cn/2021032714065464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><strong>1）副本数据同步策略</strong><br>Kafka选择了第二种方案，原因如下：</li>
</ul>
<p>1.同样为了容忍n台节点的故障，第一种方案需要2n+1个副本，而第二种方案只需要n+1个副本，而Kafka的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。<br>2.虽然第二种方案的网络延迟会比较高，但网络延迟对Kafka的影响较小。<br><img src="https://img-blog.csdnimg.cn/20210327140820226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>2）ISR</strong></li>
</ul>
<p>– 问题：<br>采用第二种方案之后，设想以下情景：leader收到数据，所有follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢？<br>– 解决：<br><strong>Leader维护了一个动态的in-sync replica set (ISR)，意为和leader保持同步的follower集合。当ISR中的follower完成数据的同步之后，leader就会给follower发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms参数设定。Leader发生故障之后，就会从ISR中选举新的leader。</strong><br>tips：满足replica.lag.time.max.ms参数设置内时间，follower被加入ISR，ISR全部同步完，即完成，<br>0.9之前还有个同步条数参数，后被移除<br>ISR包含leader<br>10s<br><img src="https://img-blog.csdnimg.cn/20210327140029551.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210327140112684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>3）ack应答机制</strong></li>
</ul>
<p>– 不重要的数据：<br>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等ISR中的follower（ISR）全部接收成功。<br>– 三种可靠级别：<br>所以Kafka为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，选择以下的配置。<br><strong>acks参数配置</strong>：<br><strong>acks：</strong><br>0：producer不等待broker的ack，这一操作提供了一个最低的延迟，broker一接收到还没有写入磁盘就已经返回，当broker故障时有可能<strong>丢失数据</strong>；<br>1：producer等待broker的ack，partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会<strong>丢失数据</strong>；<br><img src="https://img-blog.csdnimg.cn/20210327142750343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>-1（all）：producer等待broker的ack，partition的leader和follower全部落盘成功后才返回ack。但是如果在follower同步完成后，broker发送ack之前，leader发生故障，那么会造成==数据重复==。<br>tips:leader保存数据后未发生ack挂掉，生产者没收到ack，向新leader重新发送，新leader重新保存数据。<br><img src="https://img-blog.csdnimg.cn/20210327142856385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>4）故障处理细节</strong></li>
<li><em>LEO：指的是每个副本最大的offset；*</em></li>
<li><em>HW：指的是消费者能见到的最大的offset，ISR队列中最小的LEO。*</em><br>（1）follower故障<br>follower发生故障后会被临时踢出ISR，待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步。等该follower的LEO大于等于该Partition的HW，即follower追上leader之后，就可以重新加入ISR了。<br>（2）leader故障<br>leader发生故障之后，会从ISR中选出一个新的leader，之后，为保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于HW的部分截掉，然后从新的leader同步数据。（注：多了会截取，少了会同步补上）<br>==注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。==<br>tips：保证了消费一致性 存储一致性，ack 处理数据丢失和重复，此处的leader和follower都是ISR中的。<br>Log文件中的HW和LEO，如图：<br><img src="https://img-blog.csdnimg.cn/20210327150604199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h5 id="3-gt-Exactly-Once语义—精准一次性"><a href="#3-gt-Exactly-Once语义—精准一次性" class="headerlink" title="3&gt; Exactly Once语义—精准一次性"></a>3&gt; Exactly Once语义—精准一次性</h5><ul>
<li><strong>1 AtLeast Once语义：</strong> 至少一次<br>将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即AtLeast Once语义。</li>
<li><strong>2 AtMostOnce语义：</strong>至多一次<br>相对的，将服务器ACK级别设置为0，可以保证生产者每条消息只会被发送一次，即AtMostOnce语义。</li>
<li><strong>3 重复、丢失</strong><br>AtLeastOnce可以保证数据不丢失，但是不能保证数据不重复；相对的，AtLeastOnce可以保证数据不重复，但是不能保证数据不丢失。但是，<strong>对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即ExactlyOnce语义。</strong>在0.11版本以前的Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</li>
<li><strong>4 幂等性</strong></li>
</ul>
<p>0.11版本的Kafka，引入了一项重大特性：幂等性。<br>所谓的<strong>幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条</strong>。幂等性结合AtLeastOnce语义，就构成了Kafka的ExactlyOnce语义。即：<br>AtLeastOnce+幂等性=ExactlyOnce</p>
<ul>
<li><strong>5 启用幂等性</strong><br>要启用幂等性，只需要将Producer的参数中enable.idompotence设置为true即可（注，即ack=-1）。</li>
<li><strong>6 幂等实现</strong><br>Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带SequenceNumber。而<strong>Broker端</strong>会对&lt;PID, Partition,SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。<br>但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的ExactlyOnce。（注，重新建立会话，pid变化，重新发送幂等会失效）</li>
</ul>
<h4 id="4-消费者"><a href="#4-消费者" class="headerlink" title="4-消费者"></a>4-消费者</h4><h5 id="1-gt-消费方式"><a href="#1-gt-消费方式" class="headerlink" title="1&gt; 消费方式"></a>1&gt; 消费方式</h5><ul>
<li>==consumer采用pull（拉）模式从broker中读取数据。==</li>
<li><strong>push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。</strong><br>它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。</li>
<li><strong>pull模式不足之处是，如果kafka没有数据，消费者可能会陷入循环中，一直返回空数据。</strong>针对这一点，Kafka的消费者在消费数据时会传入一个时长参数timeout，如果当前没有数据可供消费，consumer会等待一段时间之后再返回，这段时长即为timeout。</li>
</ul>
<h5 id="2-gt-分区分配策略"><a href="#2-gt-分区分配策略" class="headerlink" title="2&gt; 分区分配策略"></a>2&gt; 分区分配策略</h5><ul>
<li><strong>1 分配问题</strong><br>一个consumergroup中有多个consumer，一个topic有多个partition，所以必然会涉及到partition的分配问题，即确定那个partition由哪个consumer来消费。</li>
<li><strong>2 Kafka有两种分配策略</strong><br>一是RoundRobin，一是Range（默认）。<br>（注，消费者增减需要重分配。RoundRobin直接看那个组订阅了它，组订阅了就把T1T2轮询给组，Range优先看消费者，然后再看消费者分组，/2分配给消费者组）<br>一个topic的消费，如下：<br><img src="https://img-blog.csdnimg.cn/20210327160307743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1）RoundRobin<br>好处：最多差一个<br>弊端：订阅主体一样才能使用<br><img src="https://img-blog.csdnimg.cn/20210327160446451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_10,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>多topic：<br><img src="https://img-blog.csdnimg.cn/202103271608335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>问题：<br><img src="https://img-blog.csdnimg.cn/202103271612173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210327161524488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2）Range<br>缺点：数据不均衡<br><img src="https://img-blog.csdnimg.cn/20210327161730584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>组        topic<br>轮询      面向主体  不均衡</li>
</ul>
<h5 id="3-gt-offset的维护"><a href="#3-gt-offset的维护" class="headerlink" title="3&gt; offset的维护"></a>3&gt; offset的维护</h5><p>– 由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。<br>– Kafka0.9版本之前，consumer默认将offset保存在Zookeeper中，从0.9版本开始，consumer默认将offset保存在Kafka一个内置的topic中，该topic为__consumer_offsets。<br><img src="https://img-blog.csdnimg.cn/20210327191241434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="4-gt-消费者组案例"><a href="#4-gt-消费者组案例" class="headerlink" title="4&gt; 消费者组案例"></a>4&gt; 消费者组案例</h5><p>1）需求：测试同一个消费者组中的消费者，同一时刻只能有一个消费者消费。</p>
<h4 id="5-Kafka-高效读写数据"><a href="#5-Kafka-高效读写数据" class="headerlink" title="5-Kafka 高效读写数据"></a>5-Kafka 高效读写数据</h4><p>1）顺序写磁盘<br>Kafka的producer生产数据，要写入到log文件中，写的过程是一直追加到文件末端，为顺序写。官网有数据表明，同样的磁盘，顺序写能到600M/s，而随机写只有100K/s。这与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。<br>2）零复制技术<br>正常io不包含中间那条线<br><img src="https://img-blog.csdnimg.cn/20210327191625484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>零拷贝：<br><img src="https://img-blog.csdnimg.cn/20210327192145969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="6-Zookeeper在Kafka中的作用"><a href="#6-Zookeeper在Kafka中的作用" class="headerlink" title="6-Zookeeper在Kafka中的作用"></a>6-Zookeeper在Kafka中的作用</h4><p>Kafka集群中有一个broker会被选举为Controller，负责<strong>管理集群broker的上下线</strong>，所有<strong>topic的分区副本分配和leader选举等工作</strong>。Controller的管理工作都是依赖于Zookeeper的。<br>tiips：controller选举：隔断时间看一下controller是否还在，先到先得 （Controller是kafka实例，leader是数据副本）<br>以下为partition的leader选举过程：<br><img src="https://img-blog.csdnimg.cn/20210327200206246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="7-Kafka事务"><a href="#7-Kafka事务" class="headerlink" title="7-Kafka事务"></a>7-Kafka事务</h4><p>Kafka从0.11版本开始引入了事务支持。事务可以保证Kafka在ExactlyOnce语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p>
<ul>
<li><strong>1 Producer事务</strong></li>
</ul>
<p>– 为了实现跨分区跨会话的事务，需要引入一个全局唯一的Transaction ID，并将Producer获得的PID和Transaction ID绑定。这样当Producer重启后就可以通过正在进行的Transaction ID获得原来的PID。<br>– 为了管理Transaction，Kafka引入了一个新的组件Transaction Coordinator。Producer就是通过和TransactionCoordinator交互获得TransactionID对应的任务状态。Transaction Coordinator还负责将事务所有写入Kafka的一个内部Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。<br>tips：如，30个数据，3个broker每个10个数据，第3个broker故障，重复发送，1，2重复，3不重复。上述方法是，PID和客户端事务ID关联，获取到故障前的PID，幂等。</p>
<ul>
<li><strong>2 Consumer事务</strong><br>上述事务机制主要是从Producer方面考虑，对于Consumer而言，事务的保证就会相对较弱，尤其时无法保证Commit的信息被精确消费。这是由于Consumer可以通过offset访问任意信息，而且不同的SegmentFile生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</li>
</ul>
<h2 id="二、Kafka-API"><a href="#二、Kafka-API" class="headerlink" title="二、Kafka API"></a>二、Kafka API</h2><h3 id="1-Producer-API"><a href="#1-Producer-API" class="headerlink" title="1.  Producer API"></a>1.  Producer API</h3><h4 id="1-消息发送流程"><a href="#1-消息发送流程" class="headerlink" title="1-消息发送流程"></a>1-消息发送流程</h4><p>– Kafka的Producer发送消息采用的是<strong>异步发送</strong>的方式。在消息发送的过程中，涉及到了<strong>两个线程——main线程和Sender线程，以及一个线程共享变量——RecordAccumulator</strong>。main线程将消息发送给RecordAccumulator，Sender线程不断从RecordAccumulator中拉取消息发送到Kafkabroker。<br>–相关参数：<br>batch.size：只有数据积累到batch.size之后，sender才会发送数据。<br>linger.ms：如果数据迟迟未达到batch.size，sender等待linger.time之后就会发送数据<br><img src="https://img-blog.csdnimg.cn/20210327212719353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210328135809288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-异步发送API–producer接口"><a href="#2-异步发送API–producer接口" class="headerlink" title="2-异步发送API–producer接口"></a>2-异步发送API–producer接口</h4><ul>
<li><strong>需要用到的类：</strong></li>
</ul>
<p>– KafkaProducer：需要创建一个生产者对象，用来发送数据<br>– ProducerConfig：获取所需的一系列配置参数<br>– ProducerRecord：每条数据都要封装成一个ProducerRecord对象</p>
<ul>
<li><p><strong>2种实现</strong></p>
</li>
<li><p><strong>1）不带回调函数的API</strong></p>
</li>
<li><p><strong>2）带回调函数的API</strong><br>回调函数会在producer收到ack时调用，为异步调用，该方法有两个参数，分别是RecordMetadata和Exception，如果Exception为null，说明消息发送成功，如果Exception不为null，说明消息发送失败。</p>
</li>
<li><p><em>注意：消息发送失败会自动重试，不需要我们在回调函数中手动重试。*</em></p>
</li>
</ul>
<h4 id="3-同步发送API–producer接口"><a href="#3-同步发送API–producer接口" class="headerlink" title="3 同步发送API–producer接口"></a>3 同步发送API–producer接口</h4><p>同步发送的意思就是，一条消息发送之后，会阻塞当前线程，直至返回ack。由于send方法返回的是一个Future对象，根据Futrue对象的特点，我们也可以实现同步发送的效果，只需在调用Future对象的get方发即可。</p>
<h3 id="2-Consumer-API"><a href="#2-Consumer-API" class="headerlink" title="2. Consumer API"></a>2. Consumer API</h3><ul>
<li><strong>可靠性有保证</strong><br>Consumer消费数据时的可靠性是很容易保证的，因为数据在Kafka中是持久化的，故不用担心数据丢失问题。</li>
<li><strong>offset必须考虑</strong><br>由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。</li>
<li><em>所以offset的维护是Consumer消费数据是必须考虑的问题。*</em></li>
</ul>
<h4 id="1-自动提交offset–consumer接口"><a href="#1-自动提交offset–consumer接口" class="headerlink" title="1-自动提交offset–consumer接口"></a>1-自动提交offset–consumer接口</h4><ul>
<li>编写代码需要用到的类：</li>
</ul>
<p>– KafkaConsumer：需要创建一个消费者对象，用来消费数据<br>– ConsumerConfig：获取所需的一系列配置参数<br>– ConsuemrRecord：每条数据都要封装成一个ConsumerRecord对象</p>
<ul>
<li>为了使我们能够专注于自己的业务逻辑，Kafka提供了自动提交offset的功能。<br>自动提交offset的相关参数：</li>
<li><em>enable.auto.commit*</em>：是否开启自动提交offset功能</li>
<li><em>auto.commit.interval.ms*</em>：自动提交offset的时间间隔以下为自动提交offset的代码：</li>
<li>代码如下：</li>
</ul>
<h4 id="2-手动提交offset–consumer接口"><a href="#2-手动提交offset–consumer接口" class="headerlink" title="2-手动提交offset–consumer接口"></a>2-手动提交offset–consumer接口</h4><ul>
<li><strong>1 手动 Why?</strong><br>虽然自动提交offset十分简介便利，但由于其是基于时间提交的，<strong>开发人员难以把握offset提交的时机</strong>。因此Kafka还提供了手动提交offset的API。</li>
<li><strong>2 两种方法</strong></li>
</ul>
<p>– 手动提交offset的方法有两种：分别是<strong>commitSync（同步提交）和commitAsync（异步提交）</strong>。<br>– 相同点：都会将本次poll的一批数据最高的偏移量提交；<br>– 不同点：commitSync阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致，也会出现提交失败）；而commitAsync则没有失败重试机制，故有可能提交失败。<br><strong>1）同步提交</strong><br>offset由于同步提交offset有失败重试机制，故更加可靠，以下为同步提交offset的示例。</p>
<p><strong>2）异步提交offset</strong><br>虽然同步提交offset更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞吐量会收到很大的影响。因此更多的情况下，会选用异步提交offset的方式。<br>以下为异步提交offset的示例：</p>
<p><strong>3）漏和重复</strong><br>数据漏消费和重复消费分析无论是同步提交还是异步提交offset，都有可能会造成数据的漏消费或者重复消费。<br><strong>先提交offset后消费，有可能造成数据的漏消费；而先消费后提交offset，有可能会造成数据的重复消费。</strong></p>
<h4 id="3-自定义存储offset–consumer接口"><a href="#3-自定义存储offset–consumer接口" class="headerlink" title="3-自定义存储offset–consumer接口"></a>3-自定义存储offset–consumer接口</h4><ul>
<li><strong>1 自定义存储offset</strong><br>Kafka0.9版本之前，offset存储在zookeeper，0.9版本及之后，默认将offset存储在Kafka的一个内置的topic中。除此之外，Kafka还可以选择自定义存储offset。</li>
<li><strong>2 消费者Rebalace</strong></li>
</ul>
<p>– offset的维护是相当繁琐的，因为需要考虑到消费者的Rebalace。<br>– <strong>当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发生变化，就会触发到分区的重新分配，重新分配的过程叫做Rebalance。</strong><br>–消费者发生Rebalance之后，每个消费者消费的分区就会发生变化。<strong>因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的offset位置继续消费。</strong></p>
<ul>
<li><strong>3 实现Rebalace</strong><br>要实现自定义存储offset，需要借助<strong>ConsumerRebalanceListener</strong>，以下为示例代码，其中提交和获取offset的方法，需要根据所选的offset存储系统自行实现。</li>
</ul>
<h3 id="3-自定义拦截器（Interceptor）"><a href="#3-自定义拦截器（Interceptor）" class="headerlink" title="3. 自定义拦截器（Interceptor）"></a>3. 自定义拦截器（Interceptor）</h3><h4 id="1-拦截器原理"><a href="#1-拦截器原理" class="headerlink" title="1-拦截器原理"></a>1-拦截器原理</h4><ul>
<li><strong>1 概念</strong><br>Producer拦截器(interceptor)是在Kafka 0.10版本被引入的，主要<strong>用于实现clients端的定制化控制逻辑</strong>。</li>
<li><strong>2 原理</strong><br>对于producer而言，interceptor使得用户在消息发送前以及producer回调逻辑前有机会对消息做一些定制化需求，比如修改消息等。同时，producer允许用户指定多个interceptor按序作用于同一条消息从而形成一个拦截链(interceptor chain)。<br>Intercetpor的实现接口是org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：</li>
<li><em>（1）configure(configs)*</em><br>获取配置信息和初始化数据时调用。</li>
<li><em>（2）onSend(ProducerRecord)*</em><br>该方法封装进KafkaProducer.send方法中，即它运行在用户主线程中。Producer确保在消息被序列化以及计算分区前调用该方法。<strong>用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的topic和分区</strong>，否则会影响目标分区的计算。</li>
<li><em>（3）onAcknowledgement(RecordMetadata, Exception)*</em></li>
<li><em>该方法会在消息从RecordAccumulator成功发送到KafkaBroker之后，或者在发送过程中失败时调用。*</em>并且通常都是在producer回调逻辑触发之前。onAcknowledgement运行在producer的IO线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢producer的消息发送效率。</li>
<li><em>（4）close*</em></li>
<li><em>关闭interceptor，主要用于执行一些资源清理工作*</em><br>如前所述，interceptor可能被运行在多个线程中，因此在具体实现时用户需要自行确保线程安全。另外<strong>倘若指定了多个interceptor，则producer将按照指定顺序调用它们</strong>，并仅仅是捕获每个interceptor可能抛出的异常记录到错误日志中而非在向上传递。这在使用过程中要特别留意。</li>
</ul>
<h4 id="2-拦截器案例"><a href="#2-拦截器案例" class="headerlink" title="2-拦截器案例"></a>2-拦截器案例</h4><p>1）需求：实现一个简单的双interceptor组成的拦截链。第一个interceptor会在消息发送前将时间戳信息加到消息value的最前部；第二个interceptor会在消息发送后更新成功发送消息数或失败发送消息数。<br><img src="https://img-blog.csdnimg.cn/20210328161857456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2）案例实操<br>（1）增加时间戳拦截器<br>（2）统计发送消息成功和发送失败消息数，并在producer关闭时打印这两个计数器<br>（3） producer主程序<br>3）测试<br>（1）在kafka上启动消费者，然后运行客户端java程序。<br>[atguigu@hadoop102 kafka]$ bin/kafka-console-consumer.sh --bootstrap-serverhadoop102:9092–from-beginning –topic first<br>1501904047034,message0<br>1501904047225,message1<br>1501904047230,message2<br>1501904047234,message3<br>1501904047236,message4<br>1501904047240,message5<br>1501904047243,message6<br>1501904047246,message7<br>1501904047249,message8<br>1501904047252,message9</p>
<h3 id="4-Kafka监控"><a href="#4-Kafka监控" class="headerlink" title="4. Kafka监控"></a>4. Kafka监控</h3><h4 id="1-KafkaEagle"><a href="#1-KafkaEagle" class="headerlink" title="1-KafkaEagle"></a>1-KafkaEagle</h4><p><strong>1.修改kafka启动命令</strong><br>修改kafka-server-start.sh命令中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;x$KAFKA_HEAP_OPTS&quot; &#x3D; &quot;x&quot; ]; then</span><br><span class="line">	export KAFKA_HEAP_OPTS&#x3D;&quot;-Xmx1G -Xms1G&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;x$KAFKA_HEAP_OPTS&quot; &#x3D; &quot;x&quot; ]; then</span><br><span class="line">	export KAFKA_HEAP_OPTS&#x3D;&quot;-server -Xms2G -Xmx2G -XX:PermSize&#x3D;128m -XX:+UseG1GC -XX:MaxGCPauseMillis&#x3D;200 -XX:ParallelGCThreads&#x3D;8 -XX:ConcGCThreads&#x3D;5 -XX:InitiatingHeapOccupancyPercent&#x3D;70&quot;</span><br><span class="line">	export JMX_PORT&#x3D;&quot;9999&quot;</span><br><span class="line">	#export KAFKA_HEAP_OPTS&#x3D;&quot;-Xmx1G -Xms1G&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong>注意：修改之后在启动Kafka之前要分发之其他节点</strong><br>2.上传压缩包kafka-eagle-bin-1.3.7.tar.gz到集群/opt/software目录<br>3.解压到本地<br>[atguigu@hadoop102  software]$   tar -zxvf   kafka-eagle-bin-1.3.7.tar.gz</p>
<p>4.进入刚才解压的目录<br>[atguigu@hadoop102 kafka-eagle-bin-1.3.7]$ ll<br>总用量82932<br>-rw-rw-r–. 1 atguigu atguigu 84920710 8月13 23:00 kafka-eagle-web-1.3.7-bin.tar.gz</p>
<p>5.将kafka-eagle-web-1.3.7-bin.tar.gz解压至/opt/module<br>[atguigu@hadoop102 kafka-eagle-bin-1.3.7]$ tar -zxvf kafka-eagle-web-1.3.7-bin.tar.gz -C /opt/module/</p>
<p>6.修改名称<br>[atguigu@hadoop102 module]$ mv kafka-eagle-web-1.3.7/ eagle</p>
<p>7.给启动文件执行权限[atguigu@hadoop102 eagle]$ cd bin/<br>[atguigu@hadoop102 bin]$ ll<br>总用量12<br>-rw-r–r–. 1 atguigu atguigu 1848 8月22 2017 ke.bat<br>-rw-r–r–. 1 atguigu atguigu 7190 7月30 20:12 ke.sh<br>[atguigu@hadoop102 bin]$chmod 777 ke.sh</p>
<p>8.修改配置文件<br>######################################<br>#multi zookeeper&amp;kafka cluster list<br>######################################<br>kafka.eagle.zk.cluster.alias=cluster1cluster1.zk.list=hadoop102:2181,hadoop103:2181,hadoop104:2181<br>######################################<br>#kafka offset storage<br>######################################<br>cluster1.kafka.eagle.offset.storage=kafka<br>######################################<br>#enable kafka metrics<br>######################################<br>kafka.eagle.metrics.charts=truekafka.eagle.sql.fix.error=false<br>######################################<br>#kafka jdbc driver address<br>######################################<br>kafka.eagle.driver=com.mysql.jdbc.Driverkafka.eagle.url=jdbc:mysql://hadoop102:3306/ke?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNullkafka.eagle.username=root<br>kafka.eagle.password=000000<br>9.添加环境变量<br>export KE_HOME=/opt/module/eagle<br>export PATH=$PATH:$KE_HOME/bin<br>注意：source /etc/profile<br>10.启动<br>[atguigu@hadoop102 eagle]$ bin/ke.sh start<br>… …<br>… …</p>
<hr>
<p>**</p>
<ul>
<li>Kafka Eagle Service has started success.</li>
<li>Welcome, Now you can visit ‘<a href="http://192.168.9.102:8048/ke&#39;" target="_blank" rel="noopener">http://192.168.9.102:8048/ke&#39;</a></li>
<li>Account:admin ,Password:123456</li>
</ul>
<hr>
<p>**</p>
<ul>
<li><Usage> ke.sh [start|status|stop|restart|stats] </Usage></li>
<li><Usage> <a href="https://www.kafka-eagle.org/" target="_blank" rel="noopener">https://www.kafka-eagle.org/</a> </Usage></li>
</ul>
<hr>
<p>[atguigu@hadoop102 eagle]$<br>注意：启动之前需要先启动ZK以及KAFKA<br>11.登录页面查看监控数据<br><a href="http://192.168.9.102:8048/ke第6章Flume对接Kafka1）配置flume(flume-kafka.conf)#" target="_blank" rel="noopener">http://192.168.9.102:8048/ke第6章Flume对接Kafka1）配置flume(flume-kafka.conf)#</a> definea1.sources = r1a1.sinks = k1<br><img src="https://img-blog.csdnimg.cn/20210328164438403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM0NDAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h3><p>1.Kafka中的ISR(InSyncRepli)、OSR(OutSyncRepli)、AR(AllRepli)代表什么？2.Kafka中的HW、LEO等分别代表什么？3.Kafka中是怎么体现消息顺序性的？4.Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？5.Kafka生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？6.“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？7.消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1？8.有哪些情形会造成重复消费？9.那些情景会造成消息漏消费？<br>10.当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？1）会在zookeeper中的/brokers/topics节点下创建一个新的topic节点，如：/brokers/topics/first2）触发Controller的监听程序3）kafka Controller 负责topic的创建工作，并更新metadata cache11.topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？12.topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？13.Kafka有内部的topic吗？如果有是什么？有什么所用？14.Kafka分区分配的概念？15.简述Kafka的日志目录结构？16.如果我指定了一个offset，Kafka Controller怎么查找到对应的消息？17.聊一聊Kafka Controller的作用？18.Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？19.失效副本是指什么？有那些应对措施？20.Kafka的哪些设计让它有如此高的性能？</p>
<p>区内有序：一个分区内有序<br>全局有序：一个分区+同步：get方法阻塞send</p>
<p>Kafka选举：Controller 抢资源  Leader选举 ISR  0.9前 响应时间+条数 0.9及后 响应时间</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/23/aop%EF%BC%8Cioc%EF%BC%8Ccglib%EF%BC%8Cjdk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AAlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AAlion">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/23/aop%EF%BC%8Cioc%EF%BC%8Ccglib%EF%BC%8Cjdk/" itemprop="url">aop，ioc，cglib，jdk</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-23T10:27:24+00:00">
                2020-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <ol>
<li>aop，ioc及实现原理，aop及实现，cglib，jdk动态代理实现原理，aop场景题</li>
</ol>
<p>1） aop基本概念</p>
<ul>
<li>概念：<br>AOP(Aspect-Oriented Programming)：面向切面的编程。<br>OOP(Object-Oriented Programming)面向对象的编程。<br>AOP框架是spring的一个重要组成部分。但是Spring IoC容器并不依赖于AOP，这意味着你有权利选择是否使用AOP，AOP做为Spring IoC容器的一个补充,使它成为一个强大的中间件解决方案。</li>
<li>作用：可以进行日志记录,可以进行事务管理,可以进行安全控制,可以进行异常处理,可以进行性能统计</li>
<li>3个概念：<br>a.切面：关注点形成的类，就叫切面(类)。面向切面编程，就是指对很多功能都有的重复的代码抽取，再在运行的时候网业务方法上动态植入“切面类代码”<br>b.切点：执行目标对象方法，动态植入切面代码。可以通过切入点表达式，指定拦截哪些类的哪些方法； 给指定的类在运行的时候植入切面类代码。<br>c.通知：在对象上面执行的内容。</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/04/23/aop%EF%BC%8Cioc%EF%BC%8Ccglib%EF%BC%8Cjdk/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AAlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AAlion">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/1/" itemprop="url">Java抽象类和接口的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:01+00:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p><strong>Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类</strong> </p>
</blockquote>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li><p>关键字：abstract</p>
</li>
<li><p>抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如果一个类含有抽象方法，则称这个类为抽象类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/28/1/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AAlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AAlion">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/11/" itemprop="url">Java中equals和==的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:01+00:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>equals和==的区别，两个String之间判别，两个Integer之间判别</p>
<ul>
<li><p>java中的两类数据类型</p>
<blockquote>
<ul>
<li>基本数据类型，也称原始数据类型：<br>数值型：包含整数型(byte short int long)和浮点型(float double)<br>字符型：char<br>布尔型：boolean</li>
<li>引用数据类型<br>类(class,复合数据类型）:String,Integer,Date<br>接口（interface）<br>数组（array）</li>
</ul>
</blockquote>
</li>
<li><p>“==”</p>
<blockquote>
<ul>
<li>基本数据类型。应用双等号”==”,比较的是他们的值。</li>
<li>引用数据类型。当用”==”进行比较的时候，比较的是在内存中的存放地址（堆内存地址）。<br>注：除非是同一个new出来的对象，比较后的结果为true，否则比较后结果为false。因为每new一次，都会重新开辟堆内存空间。</li>
</ul>
</blockquote>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/28/11/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AAlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AAlion">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/" itemprop="url">String的不可变性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:01+00:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">Java知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>String类被final修饰，表示不可被继承。</li>
<li>String的成员变量char[] value被final修饰，初始化后不可更改引用。</li>
<li>String的成员变量value访问修饰符为private，不对外界提供修改value数组值的方法。<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/concurrency11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AAlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AAlion">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/concurrency11/" itemprop="url">线程间通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:01+00:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>两种通信机制：共享内存和消息传递。<br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，如，共享对象进行通信。<br>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，如，wait()和notify()。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/concurrency81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AAlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AAlion">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/concurrency81/" itemprop="url">倒计时器CountDownLatch、循环栅栏CyclicBarrier</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:01+00:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h3><h4 id="一、-CountDownLatch-gt-倒计时器"><a href="#一、-CountDownLatch-gt-倒计时器" class="headerlink" title="一、 CountDownLatch-&gt;倒计时器"></a>一、 CountDownLatch-&gt;倒计时器</h4><ol>
<li><p>使用场景：在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务之后，主线程才能继续往下执行业务功能。例如，在主线程中启动10个子线程去数据库中获取分页数据，需要等到所有线程数据都返回之后统一做统计处理</p>
</li>
<li><p>例子：<br>6人运动员跑步比赛，裁判员在终点计时，可以想象每当一个运动员到达终点的时候，对于裁判员来说就少了一个计时任务。直到所有运动员都到达终点了，裁判员的任务也才完成。<br>这 6 个运动员可以类比成 6 个线程，当线程调用 CountDownLatch.countDown 方法时就会对计数器的值减一，直到计数器的值为 0 的时候，裁判员（调用 await 方法的线程）才能继续往下执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D81_CountDownLatchDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch startSingnal=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);<span class="comment">//构造方法</span></span><br><span class="line">    <span class="comment">//用来表示裁判员需要维护的是6个运动员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CountDownLatch endSingnal=<span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);<span class="comment">//构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"运动员等待裁判响哨~"</span>);</span><br><span class="line">                    startSingnal.await();<span class="comment">//等到构造方法传入的 N 减到 0 的时候，当前调用await方法的线程继续执行</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"正在冲刺~"</span>);</span><br><span class="line">                    endSingnal.countDown();<span class="comment">//使 CountDownLatch 值 N 减 1</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"到达终点~"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"裁判发令~"</span>);</span><br><span class="line">        startSingnal.countDown();</span><br><span class="line">        endSingnal.await();</span><br><span class="line">        System.out.println(<span class="string">"全部到达终点，比赛结束~"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>运动员等待裁判响哨~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>运动员等待裁判响哨~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>运动员等待裁判响哨~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>运动员等待裁判响哨~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>运动员等待裁判响哨~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>运动员等待裁判响哨~</span><br><span class="line">裁判发令~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在冲刺~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>到达终点~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>正在冲刺~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>到达终点~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>正在冲刺~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>到达终点~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在冲刺~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>到达终点~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>正在冲刺~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>到达终点~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>正在冲刺~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>到达终点~</span><br><span class="line">全部到达终点，比赛结束~</span><br></pre></td></tr></table></figure>
<h4 id="二、-CyclicBarrier-gt-循环栅栏"><a href="#二、-CyclicBarrier-gt-循环栅栏" class="headerlink" title="二、 CyclicBarrier-&gt;循环栅栏"></a>二、 CyclicBarrier-&gt;循环栅栏</h4></li>
<li><p>例子<br>开运动会时，会有跑步这一项运动，我们来模拟下运动员入场时的情况，假设有 6 条跑道，在比赛开始时，就需要 6 个运动员在比赛开始的时候都站在起点了，裁判员吹哨后才能开始跑步。跑道起点就相当于“barrier”，是临界点，而这 6 个运动员就类比成线程的话，就是这 6 个线程都必须到达指定点了，意味着凑齐了一波，然后才能继续执行，否则每个线程都得阻塞等待，直至凑齐一波即可。cyclic 是循环的意思，也就是说 CyclicBarrier 当多个线程凑齐了一波之后，仍然有效，可以继续凑齐下一波。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定必须有6个运动员到达才行,构造方法public CyclicBarrier(int parties, Runnable barrierAction)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">6</span>, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"所有运动员已入场，裁判吹起跑哨~"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运动员准备入场，欢呼~"</span>);</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"运动员，进场"</span>);</span><br><span class="line">                    barrier.await();<span class="comment">//等到所有的线程都到达指定的临界点:6人到齐</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"运动员出发~"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、-区别"><a href="#三、-区别" class="headerlink" title="三、 区别"></a>三、 区别</h4></li>
<li><p>CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进。</p>
</li>
<li><p>调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用 CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；</p>
</li>
<li><p>CountDownLatch 方法比较少，操作比较简单，而 CyclicBarrier 提供的方法更多，比如能够通过 getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且 CyclicBarrier 的构造方法可以传入 barrierAction，指定当所有线程都到达时执行的业务功能；</p>
</li>
<li><p>CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/concurrency82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AAlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AAlion">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/concurrency82/" itemprop="url">控制资源并发访问Semaphore</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:01+00:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h3><h4 id="一、-Semaphore-gt-控制资源并发访问"><a href="#一、-Semaphore-gt-控制资源并发访问" class="headerlink" title="一、 Semaphore-&gt;控制资源并发访问"></a>一、 Semaphore-&gt;控制资源并发访问</h4><ol>
<li><p>Semaphore 可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定限制资源。</p>
</li>
<li><p>场景：Semaphore 可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。<br>假如有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有 10 个，这时候就需要使用 Semaphore 来控制能够并发访问到数据库连接资源的线程个数最多只有 10 个。在限制资源使用的应用场景下，Semaphore 是特别合适的。</p>
</li>
<li><p>场景：我们来模拟这样一样场景。有一天，班主任需要班上 10 个同学到讲台上来填写一个表格，但是老师只准备了 5 支笔，因此，只能保证同时只有 5 个同学能够拿到笔并填写表格，没有获取到笔的同学只能够等前面的同学用完之后，才能拿到笔去填写表格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示老师只有3支笔</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//表示6个学生使用</span></span><br><span class="line">        ExecutorService service= Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"学生准备获取笔"</span>);</span><br><span class="line">                    semaphore.acquire();<span class="comment">//获取许可，如果无法获取到，则阻塞等待直至能够获取为止</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"学生获取到笔，并填写表格..."</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"填写完表格，并还笔~"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>学生准备获取笔</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>学生获取到笔，并填写表格...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>学生准备获取笔</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>学生获取到笔，并填写表格...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>学生准备获取笔</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>学生获取到笔，并填写表格...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>学生准备获取笔</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>学生准备获取笔</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>学生准备获取笔</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>填写完表格，并还笔~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>学生获取到笔，并填写表格...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>填写完表格，并还笔~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>填写完表格，并还笔~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>学生获取到笔，并填写表格...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>学生获取到笔，并填写表格...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>填写完表格，并还笔~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>填写完表格，并还笔~</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>填写完表格，并还笔~</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>其他例子<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConcurrency</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//控制方法的并发量（Semaphore信号量方案）&gt;&gt;&gt;&gt;&gt;200</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">200</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//无参方法tryAcquire（）的作用是尝试的获得1个许可，如果获取不到则返回false</span></span><br><span class="line">		<span class="keyword">if</span>(!semaphore.tryAcquire()) </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"并发超过200"</span>);</span><br><span class="line">		String A = <span class="string">"业务逻辑"</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// TODO 方法中的业务逻辑</span></span><br><span class="line">			System.out.println(A);</span><br><span class="line">			<span class="keyword">return</span> A;</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			</span><br><span class="line">			semaphore.release();</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/concurrency83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AAlion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AAlion">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/concurrency83/" itemprop="url">线程间交换数据的工具Exchanger</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:01+00:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h3><h4 id="2-Exchanger-gt-线程间交换数据的工具"><a href="#2-Exchanger-gt-线程间交换数据的工具" class="headerlink" title="2 Exchanger-&gt;线程间交换数据的工具"></a>2 Exchanger-&gt;线程间交换数据的工具</h4><p>Exchanger 是一个用于线程间协作的工具类，用于两个线程间能够交换。它提供了一个交换的同步点，在这个同步点两个线程能够交换彼此的数据。<br>们来模拟这样一个情景，在青春洋溢的中学时代，下课期间，男生经常会给走廊里为自己喜欢的女孩子送情书，相信大家都做过这样的事情吧 ：)。男孩会先到女孩教室门口，然后等女孩出来，教室那里就是一个同步点，然后彼此交换信物，也就是彼此交换了数据。</p>
<ol>
<li>如下，说话内容有交换：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两个线程代表你和快递员</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        service.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//朋友对你说的话</span></span><br><span class="line">                String friend = exchanger.exchange(<span class="string">"等你很久了~~"</span>);</span><br><span class="line">                System.out.println(<span class="string">"朋友说："</span>+friend);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"朋友从远处走来..."</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">//你对朋友说的话</span></span><br><span class="line">                String you=exchanger.exchange(<span class="string">"我也等你很久了。。。"</span>);</span><br><span class="line">                System.out.println(<span class="string">"你说："</span>+you);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>输出结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">朋友从远处走来...</span><br><span class="line">朋友说：我也等你很久了。。。</span><br><span class="line">你说：等你很久了~~</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">AAlion</p>
              <p class="site-description motion-element" itemprop="description">Happy Code, Happy Life</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AAlion</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
